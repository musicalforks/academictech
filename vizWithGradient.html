<!--Program including HTML, CSS, Javascript to display data-driven graph visualization from Omeka API data-->
<!DOCTYPE html>
<meta charset="utf-8">
<head><link href="https://fonts.googleapis.com/css?family=Crimson+Text" rel="stylesheet"></head>


<!--Beginning of CSS stylesheet-->
<style>
	
body {
	font-family: 'Crimson Text', serif;
    font-size: 15px;
      }

.node text {
  pointer-events: none;
  font: 10px 'Avro';
}
	
.themes {}
.orgs {}
.center {}

</style>

<!--Beginning of JavaScript/D3 program-->

<script src="https://d3js.org/d3.v3.js"></script>
<body>
<script>	
//Initialize svg with gray background and physics model for visualization	
var width = window.innerWidth - 20;
    height = window.innerHeight - 25;

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

svg.append("rect")
      .attr("x", 0)
      .attr("y", 0)
	  .attr("fill", d3.rgb(240,248,255))
      .attr("width", width)
      .attr("height", height);

var force = d3.layout.force()
    .gravity(0.01)
    .distance(150)
    .charge(-1300)
    .size([width, height]);

//Stores dicts representing themes and orgs to display as nodes	
var nodes = [];
//Stores links between themes and orgs
var links = [];
//Stores names of themes
var themeList = [];
var numThemes = 0;
	
/*Complete API requests, format resulting JSON to usable data, and visualize the data*/
	
//Send API requests for theme data (GET all tags) and format resulting JSON
d3.json("https://constellation.carletonds.com/api/tags?pretty_print", function(data1) {
	//Send API requests for org data (GET all items of Organization Item type) and format resulting JSON
	d3.json("https://constellation.carletonds.com/api/items/?item_type=19", function(data2){
		d3.json("https://constellation.carletonds.com/api/items/?item_type=20", function(data3){
     
	  /*Formatting API JSON returns to correct data format*/
	  //Get themes (GET all tags) and put into list
	  for (var idx = 0; idx < data1.length; idx++){
		var tag = data1[idx].name;	
		themeList.push(tag);
	  }
	  numThemes = data1.length;
	  //Create dict for each theme and add to nodes
	  for (var idx = 0; idx < themeList.length; idx++){	
		var themeDict = {};
		themeDict = {"id": idx, "name": themeList[idx], "level": "0", "themes": [themeList[idx]]};
		nodes.push(themeDict);
	  }
			  
			  
	  //GET all items of Organization Item Type, and create dict for each org and add to nodes
	  for (var orgIdx = 0; orgIdx < data2.length; orgIdx++){
		  var url, logo, logoOrient, name;
		  //Match up url, logo, logo orientation, name fields correctly for each org
		  for(var itemInfo = 0; itemInfo < 4; itemInfo++){
			  var field = data2[orgIdx].element_texts[itemInfo].text;
			  if(data2[orgIdx].element_texts[itemInfo].element.name == "Title"){
				  name = field;
			  }else if(data2[orgIdx].element_texts[itemInfo].element.name == "URL"){
			  	  url = field;
			  }else if(data2[orgIdx].element_texts[itemInfo].element.name == "Logo orientation"){
			  	  logoOrient = field;
			  }else{
				  logo = field;
			  }
		  }
		  var themes = [];
		  //For loop to add themes key as a list of themes (tags related to org)
		  //And to add links between themes and org by id
		  for (var themeIdx = 0; themeIdx < data2[orgIdx].tags.length; themeIdx++){
			  themes.push(data2[orgIdx].tags[themeIdx].name);
			  //Find the theme id
			  var idIterator = 0;
			  while(data2[orgIdx].tags[themeIdx].name != themeList[idIterator]){
				  idIterator++;
			  }
			  var link = {"source": orgIdx+numThemes, "target": idIterator, "type": "org-theme"}
			  links.push(link);
		  }
		  var orgDict = {};
		  orgDict = {"id": orgIdx+numThemes, "name": name, "level": "1", "logo": logo, "logoOrient": logoOrient, "url": url, "themes": themes};
		  nodes.push(orgDict);
	  }

	  //Add project title node and link it to all theme nodes
	  var centerIdx = nodes.length;
	  for (var themesToLink = 0; themesToLink < numThemes; themesToLink++){
	  	var link = {"source": centerIdx, "target": themesToLink, "type": "theme-center"}
		links.push(link);
	  }
	  var centerNode = {};
	  var name = data3[0].element_texts[0].text;
	  var url = data3[0].element_texts[1].text;
	  centerNode = {"id": nodes.length, "name": name, "level": "2", "url": url, "themes": []};
	  nodes.push(centerNode);  
			  
	   /*Begin displaying data stored by nodes and links in visualization*/
	   force
      .nodes(nodes)
      .links(links)
      .start();

  //Display links using links list		
  var link = svg.selectAll(".link")
      .data(links)
    .enter().append("line")
      .attr("class", "link")
  	  .attr("stroke-width", linkWeight)
 	  .attr("stroke", linkColorGradient);
  
  //Select and class nodes using nodes list
  var node = svg.selectAll(".node")
      .data(nodes)
      .enter().append("g")
      .attr("class", "node")
      //Class nodes by theme/org class type
  	  .attr("class", isThemeOrOrg)
      .call(force.drag);
	
	//Display theme nodes as circle colored by theme color and captioned by theme name
  	var themes = svg.selectAll(".themes")
	  themes.append("circle")
      .attr("r", 42)
      .attr("fill", circleColor)
	  themes.append("text")
      .text(function(d) { return d.name })
	  .attr("text-anchor", "middle")
	  .style("fill", d3.rgb(178,34,34))
	  .call(wrap, 80);

	//Display org nodes as logo image with hyperlink to org's Collection page
  	var orgs = svg.selectAll(".orgs")
	  orgs.append("image")
      .attr("xlink:href", function(d){return d.logo})
      .attr("x", imgParamX)
      .attr("y", imgParamY)
      .attr("width", imgParamWidth)
      .attr("height", imgParamHeight);
	  orgs.append("a")
      .attr("xlink:href", function(d){return d.url})
	  .append("rect")
	  .attr("y", imgParamX)
      .attr("x", imgParamY)
      .attr("width", imgParamWidth) 
      .attr("height", imgParamHeight)
	  .style("fill-opacity", .0000000000001);
			  
	//Display center node
  	var center = svg.selectAll(".center")
	  .append("a")
      .attr("xlink:href", function(d){return d.url})
	  center.append("circle")
      .attr("r", 55)
      .attr("fill", "#aaa")
	  center.append("text")
      .text(function(d) { return d.name })
	  .attr("text-anchor", "middle")
	  .style("fill", d3.rgb(178,34,34))
	  .call(wrap, 105);			
			
  //Complete drawing all items on svg
  force.on("tick", function() {
    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });
    //Visualization is responsive to user input (dragging nodes)
    node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
	//Force center node to center
	nodes[nodes.length-1].x = width / 2;
    nodes[nodes.length-1].y = height / 2;
  });
	
	});
});
});

/********************HELPER FUNCTIONS********************/	
	
/*Function to determine if node is theme or org*/	
function isThemeOrOrg(d){
	if (d.level == "0"){
		return "themes";
	}else if (d.level == "1"){
		return "orgs";
	}else{
		return "center";
	}
}
	
/*Helper function to determine theme node's color
//////////////////////////////EDIT 'themeColorKey' VAR HERE//////////////////////////////////
Culture of Care / Cultura del Cuidado (Purple)
Sustainnable Living / Vivienda sostenible (Green-like the color of the grass)
Social Ecology / Ecología Social (Dark green)
Alternative Education/ Educación alternativa (White)
Indi-Media / Medios de comunicación  independientes (Salmon)
Performative Culture/ Cultura performativa de lo cotidiano (Majenta)
Transitional Cities and Municipalism / Ciudades en transición y Municipalismo (Dark Orange)
Cultural Essays of the Commons/ Ensayos culturales del común (lemonish)*/
	
var themeColorKey = {
	"culture of care": [154, 126, 191],
	"sustainable living": [179, 232, 156],
	"social ecology": [60,179,113],
	"alternative education": [237, 237, 244],
	"indi-media": [255, 153, 153],
	"performative culture": [219,112,147],
	"transitional cities": [255,165,0],
	"cultural essays": [255,255,153]
	};

function circleColor(d){
	var theme = d.themes[0];
	return d3.rgb(themeColorKey[theme][0], themeColorKey[theme][1],themeColorKey[theme][2]);
}

/*Create gradient obj to determine color gradient for each link*/
function linkColorGradient(d){
	var defs = svg.append("defs");

	var gradient = defs.append("linearGradient")
	   .attr("id", "svgGradient" + d.source.name.toString().replace(/\s/g, '') + d.target.name.toString().replace(/\s/g, ''))
	   .attr("x1", "0%")
	   .attr("x2", "100%")
	   .attr("y1", "0%")
	   .attr("y2", "100%");
var color1 = linkColorSource(d);
	gradient.append("stop")
	   .attr('class', 'start')
	   .attr("offset", "0%")
	   .attr("stop-color", color1)
	   .attr("stop-opacity", 1);
var color2 = linkColorTarget(d);
	gradient.append("stop")
	   .attr('class', 'end')
	   .attr("offset", "100%")
	   .attr("stop-color", color2)
	   .attr("stop-opacity", 1);
	
	return "url(#svgGradient" + d.source.name.toString().replace(/\s/g, '') + d.target.name.toString().replace(/\s/g, '') + ")";
}	

/*Determine first color for link color gradient*/
function linkColorSource(d){
	if(d.type == "theme-center"){
		var theme = d.target.themes[0];
	}
	else{
		var theme = d.source.themes[0];
	}
	return d3.rgb(themeColorKey[theme][0],themeColorKey[theme][1],themeColorKey[theme][2]);
}
	
/*Determine second color for link color gradient*/
function linkColorTarget(d){
	
	if(d.type == "theme-center"){
		var theme = d.target.themes[0];
		return d3.rgb(themeColorKey[theme][0],themeColorKey[theme][1],themeColorKey[theme][2]);
	}
	//avg rgb color for all tagged themes of a org node
	else{
		var themeList = d.target.themes;

		var r, g, b;
		r = themeColorKey[themeList[0]][0];
		g = themeColorKey[themeList[0]][1];
		b = themeColorKey[themeList[0]][2];
		for(var theme=1; theme < themeList.length; theme++){
			r = avgRgb(r, themeColorKey[themeList[theme]][0], 1);
			g = avgRgb(r, themeColorKey[themeList[theme]][1], 1);
			b = avgRgb(r, themeColorKey[themeList[theme]][2], 1);
		}
		return d3.rgb(r, g, b);
	}
}	
	
/*Avg two r/g/b values by first squaring them, then avergaging the squared values,
(here the first value can be weighted), and then finally taking the square root of that average*/
function avgRgb(rgb1, rgb2, weight){
	var rgb1Sq = Math.pow(rgb1, 2)
	var rgb2Sq = Math.pow(rgb2, 2)
	return Math.sqrt(((weight * rgb1Sq) + rgb2Sq)/2);	
}
/*Determines stroke weight of a link*/
function linkWeight(d){
	if(d.type == "org-theme"){
		return 3.75;
	}else if(d.type == "theme-center"){
		return 7;
	}
}

/*Series of helper functions to position and size logo images depending on logo orientation*/	
function imgParamX(d){
	if(d.logoOrient == "rectangular"){
		return "-40";
	}else if(d.logoOrient == "square"){
		return -20;
	}
}
function imgParamY(d){
	if(d.logoOrient == "rectangular"){
		return -30;
	}else if(d.logoOrient == "square"){
		return -20;
	}
}
function imgParamWidth(d){
	if(d.logoOrient == "rectangular"){
		return 80;
	}else if(d.logoOrient == "square"){
		return 40;
	}
}function imgParamHeight(d){
	if(d.logoOrient == "rectangular"){
		return 40;
	}else if(d.logoOrient == "square"){
		return 40;
	}
}
	
/*D3 text wrapping
Open-source credit: https://bl.ocks.org/mbostock/7555321*/	
function wrap(text, width) {
  text.each(function() {
    var text = d3.select(this),
        words = text.text().split(/\s+/).reverse(),
        word,
        line = [],
        lineNumber = 0,
        lineHeight = 1.1, // ems
        y = text.attr("y"),
        //dy = parseFloat(text.attr("dy")),
		dy = 0,
        tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
    while (word = words.pop()) {
      line.push(word);
      tspan.text(line.join(" "));
      if (tspan.node().getComputedTextLength() > width) {
        line.pop();
        tspan.text(line.join(" "));
        line = [word];
        tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
      }
    }
  });
}

/*Delete duplicate elements from array
Open-source credit: 
https://stackoverflow.com/questions/1584370/how-to-merge-two-arrays-in-javascript-and-de-duplicate-items*/
Array.prototype.unique = function() {
    var a = this.concat();
    for(var i=0; i<a.length; ++i) {
        for(var j=i+1; j<a.length; ++j) {
            if(a[i] === a[j])
                a.splice(j--, 1);
        }
    }

    return a;
};

</script>
